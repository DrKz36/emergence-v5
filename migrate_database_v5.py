"""
√âMERGENCE V5 - DATABASE MIGRATION SCRIPT
üî• Migration database principale pour tables sessions + m√©moire persistante
Version: 5.0.0 - Sessions Tables + FTS5 + Backward Compatibility
"""

import os
import sqlite3
import logging
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Tuple

# Configuration logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DatabaseMigrationV5:
    """
    üöÄ MIGRATION DATABASE V5 - TABLES SESSIONS
    
    Responsabilit√©s :
    - Ajouter tables sessions sans casser l'existant
    - Migration donn√©es existantes si n√©cessaire  
    - V√©rification int√©grit√© post-migration
    - Backup automatique avant migration
    - Rollback si √©chec
    """
    
    def __init__(self, database_path: str = "data/emergence_v4.db"):
        self.database_path = database_path
        self.backup_path = f"{database_path}.backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.migration_version = "5.0.0"
        
        logger.info(f"üîß Migration Database V5 initialis√©e")
        logger.info(f"üìÇ Database: {database_path}")
        logger.info(f"üíæ Backup: {self.backup_path}")
    
    def check_database_exists(self) -> bool:
        """üîç V√©rification existence database"""
        exists = os.path.exists(self.database_path)
        logger.info(f"üìä Database exists: {exists}")
        return exists
    
    def create_backup(self) -> bool:
        """üíæ Cr√©ation backup avant migration"""
        try:
            if not self.check_database_exists():
                logger.warning("‚ö†Ô∏è Database n'existe pas - pas de backup n√©cessaire")
                return True
                
            # Copie fichier database
            import shutil
            shutil.copy2(self.database_path, self.backup_path)
            
            # V√©rification backup
            backup_size = os.path.getsize(self.backup_path)
            original_size = os.path.getsize(self.database_path)
            
            if backup_size == original_size:
                logger.info(f"‚úÖ Backup cr√©√©: {self.backup_path} ({backup_size} bytes)")
                return True
            else:
                logger.error(f"‚ùå Backup invalide: tailles diff√©rentes")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation backup: {e}")
            return False
    
    def get_current_schema_version(self) -> str:
        """üìã R√©cup√©ration version sch√©ma actuel"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                # Check si table metadata existe
                cursor.execute("""
                    SELECT name FROM sqlite_master 
                    WHERE type='table' AND name='schema_metadata'
                """)
                
                if cursor.fetchone():
                    cursor.execute("SELECT version FROM schema_metadata ORDER BY created_at DESC LIMIT 1")
                    result = cursor.fetchone()
                    version = result[0] if result else "4.0.0"
                else:
                    # Pas de table metadata = version 4.0.0 (legacy)
                    version = "4.0.0"
                
                logger.info(f"üìã Version sch√©ma actuelle: {version}")
                return version
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lecture version sch√©ma: {e}")
            return "unknown"
    
    def check_existing_tables(self) -> Dict[str, bool]:
        """üîç V√©rification tables existantes"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT name FROM sqlite_master 
                    WHERE type='table'
                    ORDER BY name
                """)
                
                existing_tables = [row[0] for row in cursor.fetchall()]
                
                # Tables V4 attendues
                expected_v4_tables = [
                    'conversations', 'documents', 'chunks', 'interactions'
                ]
                
                # Tables V5 nouvelles
                new_v5_tables = [
                    'sessions', 'session_messages', 'session_messages_fts',
                    'agent_memories', 'concept_timeline', 'thinking_patterns',
                    'schema_metadata'
                ]
                
                table_status = {}
                
                # Check V4 tables
                for table in expected_v4_tables:
                    table_status[f"v4_{table}"] = table in existing_tables
                
                # Check V5 tables
                for table in new_v5_tables:
                    table_status[f"v5_{table}"] = table in existing_tables
                
                logger.info(f"üîç Tables existantes: {len(existing_tables)}")
                logger.info(f"   V4 tables: {[k for k,v in table_status.items() if k.startswith('v4_') and v]}")
                logger.info(f"   V5 tables: {[k for k,v in table_status.items() if k.startswith('v5_') and v]}")
                
                return table_status
                
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification tables: {e}")
            return {}
    
    def create_schema_metadata_table(self) -> bool:
        """üìä Cr√©ation table metadata sch√©ma"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS schema_metadata (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        version TEXT NOT NULL,
                        migration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        description TEXT,
                        tables_added TEXT,  -- JSON list
                        migration_notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                conn.commit()
                logger.info("‚úÖ Table schema_metadata cr√©√©e")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation schema_metadata: {e}")
            return False
    
    def create_sessions_tables(self) -> bool:
        """üóÑÔ∏è Cr√©ation tables sessions V5"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                # Table sessions principales
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS sessions (
                        id TEXT PRIMARY KEY,
                        user_id TEXT NOT NULL DEFAULT 'FG',
                        start_time TIMESTAMP,
                        end_time TIMESTAMP,
                        session_data TEXT,  -- JSON complet
                        themes TEXT,        -- JSON array themes
                        agents_used TEXT,   -- JSON array agents
                        modes_used TEXT,    -- JSON array modes
                        documents_used TEXT, -- JSON array documents
                        total_cost REAL DEFAULT 0.0,
                        message_count INTEGER DEFAULT 0,
                        session_duration_minutes REAL DEFAULT 0.0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Table messages sessions pour recherche
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS session_messages (
                        rowid INTEGER PRIMARY KEY AUTOINCREMENT,
                        session_id TEXT NOT NULL,
                        message_text TEXT NOT NULL,
                        agent TEXT,
                        sender TEXT NOT NULL,
                        mode TEXT DEFAULT 'dialogue',
                        timestamp TEXT NOT NULL,
                        metadata TEXT,  -- JSON
                        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE
                    )
                """)
                
                # Table FTS5 pour recherche full-text dans messages
                cursor.execute("""
                    CREATE VIRTUAL TABLE IF NOT EXISTS session_messages_fts USING fts5(
                        session_id,
                        message_text,
                        agent,
                        mode,
                        timestamp,
                        content='session_messages',
                        content_rowid='rowid'
                    )
                """)
                
                # Index pour performance
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_user_date ON sessions (user_id, start_time)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_themes ON sessions (themes)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_cost ON sessions (total_cost)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_messages_session ON session_messages (session_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_messages_agent ON session_messages (agent)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_messages_timestamp ON session_messages (timestamp)")
                
                conn.commit()
                logger.info("‚úÖ Tables sessions V5 cr√©√©es avec index")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation tables sessions: {e}")
            return False
    
    def create_memory_tables(self) -> bool:
        """üß† Cr√©ation tables m√©moire agents V5"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                # Table m√©moire agents
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS agent_memories (
                        id TEXT PRIMARY KEY,
                        agent_name TEXT NOT NULL,
                        user_id TEXT NOT NULL DEFAULT 'FG',
                        memory_type TEXT NOT NULL,  -- context, pattern, preference, interaction
                        memory_data TEXT NOT NULL,  -- JSON
                        importance_score REAL DEFAULT 0.5,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        access_count INTEGER DEFAULT 0,
                        expires_at TIMESTAMP,  -- NULL = permanent
                        tags TEXT  -- JSON array
                    )
                """)
                
                # Table timeline concepts
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS concept_timeline (
                        id TEXT PRIMARY KEY,
                        user_id TEXT NOT NULL DEFAULT 'FG',
                        concept_name TEXT NOT NULL,
                        session_id TEXT,
                        mentioned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        context_snippet TEXT,
                        sentiment_score REAL DEFAULT 0.0,  -- -1.0 to 1.0
                        evolution_stage TEXT,  -- discovery, exploration, consolidation, mastery
                        related_concepts TEXT,  -- JSON array
                        FOREIGN KEY (session_id) REFERENCES sessions (id)
                    )
                """)
                
                # Table patterns de pens√©e
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS thinking_patterns (
                        id TEXT PRIMARY KEY,
                        user_id TEXT NOT NULL DEFAULT 'FG',
                        pattern_type TEXT NOT NULL,  -- recurrent_theme, question_style, reasoning_approach
                        pattern_data TEXT NOT NULL,  -- JSON description pattern
                        confidence_score REAL DEFAULT 0.5,
                        first_detected TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_confirmed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        occurrences INTEGER DEFAULT 1,
                        examples TEXT,  -- JSON array examples
                        status TEXT DEFAULT 'active'  -- active, dormant, evolved
                    )
                """)
                
                # Index pour performance m√©moire
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_agent_memories_agent_user ON agent_memories (agent_name, user_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_agent_memories_type ON agent_memories (memory_type)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_agent_memories_importance ON agent_memories (importance_score DESC)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_concept_timeline_user_concept ON concept_timeline (user_id, concept_name)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_concept_timeline_session ON concept_timeline (session_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_thinking_patterns_user_type ON thinking_patterns (user_id, pattern_type)")
                
                conn.commit()
                logger.info("‚úÖ Tables m√©moire agents V5 cr√©√©es avec index")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation tables m√©moire: {e}")
            return False
    
    def update_schema_version(self, tables_added: List[str]) -> bool:
        """üìù Mise √† jour version sch√©ma"""
        try:
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    INSERT INTO schema_metadata (
                        version, description, tables_added, migration_notes
                    ) VALUES (?, ?, ?, ?)
                """, (
                    self.migration_version,
                    "Migration V5 - Tables sessions + m√©moire persistante",
                    json.dumps(tables_added),
                    "Ajout fonctionnalit√©s Phase 2: sessions, agent memory, timeline, patterns"
                ))
                
                conn.commit()
                logger.info(f"‚úÖ Version sch√©ma mise √† jour: {self.migration_version}")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Erreur mise √† jour version sch√©ma: {e}")
            return False
    
    def verify_migration(self) -> Dict[str, Any]:
        """üîç V√©rification int√©grit√© post-migration"""
        try:
            verification = {
                "success": True,
                "tables_created": [],
                "indexes_created": [],
                "errors": [],
                "warnings": []
            }
            
            with sqlite3.connect(self.database_path) as conn:
                cursor = conn.cursor()
                
                # V√©rification tables cr√©√©es
                expected_tables = [
                    'sessions', 'session_messages', 'session_messages_fts',
                    'agent_memories', 'concept_timeline', 'thinking_patterns',
                    'schema_metadata'
                ]
                
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                existing_tables = [row[0] for row in cursor.fetchall()]
                
                for table in expected_tables:
                    if table in existing_tables:
                        verification["tables_created"].append(table)
                    else:
                        verification["errors"].append(f"Table {table} non cr√©√©e")
                        verification["success"] = False
                
                # V√©rification index
                cursor.execute("SELECT name FROM sqlite_master WHERE type='index' AND name LIKE 'idx_%'")
                indexes = [row[0] for row in cursor.fetchall()]
                verification["indexes_created"] = indexes
                
                # Test simple insertion/lecture
                try:
                    cursor.execute("INSERT INTO schema_metadata (version, description) VALUES (?, ?)", 
                                   ("test", "Migration verification test"))
                    cursor.execute("DELETE FROM schema_metadata WHERE version = 'test'")
                    conn.commit()
                except Exception as e:
                    verification["errors"].append(f"Test insertion failed: {e}")
                    verification["success"] = False
                
                # Statistiques
                cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
                total_tables = cursor.fetchone()[0]
                
                verification["stats"] = {
                    "total_tables": total_tables,
                    "v5_tables_added": len(verification["tables_created"]),
                    "indexes_created": len(verification["indexes_created"])
                }
                
                logger.info(f"üîç V√©rification migration: {'‚úÖ SUCCESS' if verification['success'] else '‚ùå FAILED'}")
                logger.info(f"   Tables cr√©√©es: {len(verification['tables_created'])}/{len(expected_tables)}")
                logger.info(f"   Index cr√©√©s: {len(verification['indexes_created'])}")
                
                return verification
                
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification migration: {e}")
            return {
                "success": False,
                "errors": [str(e)],
                "tables_created": [],
                "indexes_created": []
            }
    
    def rollback_migration(self) -> bool:
        """üîÑ Rollback en cas d'√©chec"""
        try:
            if not os.path.exists(self.backup_path):
                logger.error(f"‚ùå Backup non trouv√©: {self.backup_path}")
                return False
            
            # Restauration backup
            import shutil
            shutil.copy2(self.backup_path, self.database_path)
            
            logger.info(f"üîÑ Rollback effectu√© depuis {self.backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur rollback: {e}")
            return False
    
    def run_migration(self) -> Dict[str, Any]:
        """üöÄ Ex√©cution migration compl√®te"""
        migration_result = {
            "success": False,
            "steps_completed": [],
            "errors": [],
            "backup_created": False,
            "rollback_performed": False,
            "verification": {}
        }
        
        try:
            logger.info("üöÄ D√âBUT MIGRATION DATABASE V5")
            
            # √âtape 1: Backup
            logger.info("üìù √âtape 1: Cr√©ation backup...")
            if self.create_backup():
                migration_result["backup_created"] = True
                migration_result["steps_completed"].append("backup")
            else:
                migration_result["errors"].append("√âchec cr√©ation backup")
                return migration_result
            
            # √âtape 2: Version actuelle
            logger.info("üìã √âtape 2: V√©rification version actuelle...")
            current_version = self.get_current_schema_version()
            migration_result["current_version"] = current_version
            migration_result["steps_completed"].append("version_check")
            
            # √âtape 3: Tables existantes
            logger.info("üîç √âtape 3: V√©rification tables existantes...")
            existing_tables = self.check_existing_tables()
            migration_result["existing_tables"] = existing_tables
            migration_result["steps_completed"].append("tables_check")
            
            # √âtape 4: Schema metadata
            logger.info("üìä √âtape 4: Cr√©ation table schema metadata...")
            if self.create_schema_metadata_table():
                migration_result["steps_completed"].append("schema_metadata")
            else:
                migration_result["errors"].append("√âchec cr√©ation schema_metadata")
                
            # √âtape 5: Tables sessions
            logger.info("üóÑÔ∏è √âtape 5: Cr√©ation tables sessions...")
            if self.create_sessions_tables():
                migration_result["steps_completed"].append("sessions_tables")
            else:
                migration_result["errors"].append("√âchec cr√©ation tables sessions")
                
            # √âtape 6: Tables m√©moire
            logger.info("üß† √âtape 6: Cr√©ation tables m√©moire...")
            if self.create_memory_tables():
                migration_result["steps_completed"].append("memory_tables")
            else:
                migration_result["errors"].append("√âchec cr√©ation tables m√©moire")
            
            # √âtape 7: Mise √† jour version
            logger.info("üìù √âtape 7: Mise √† jour version sch√©ma...")
            tables_added = [
                'sessions', 'session_messages', 'session_messages_fts',
                'agent_memories', 'concept_timeline', 'thinking_patterns'
            ]
            if self.update_schema_version(tables_added):
                migration_result["steps_completed"].append("version_update")
            else:
                migration_result["errors"].append("√âchec mise √† jour version")
            
            # √âtape 8: V√©rification
            logger.info("üîç √âtape 8: V√©rification int√©grit√©...")
            verification = self.verify_migration()
            migration_result["verification"] = verification
            migration_result["steps_completed"].append("verification")
            
            # R√©sultat final
            if verification["success"] and len(migration_result["errors"]) == 0:
                migration_result["success"] = True
                logger.info("‚úÖ MIGRATION V5 R√âUSSIE")
            else:
                migration_result["errors"].extend(verification.get("errors", []))
                logger.warning("‚ö†Ô∏è MIGRATION V5 PARTIELLE OU √âCHEC")
                
                # Rollback si √©chec critique
                if len(verification.get("errors", [])) > 0:
                    logger.info("üîÑ Tentative rollback...")
                    if self.rollback_migration():
                        migration_result["rollback_performed"] = True
            
            return migration_result
            
        except Exception as e:
            logger.error(f"‚ùå ERREUR CRITIQUE MIGRATION: {e}")
            migration_result["errors"].append(f"Erreur critique: {e}")
            
            # Rollback automatique
            logger.info("üîÑ Rollback automatique...")
            if self.rollback_migration():
                migration_result["rollback_performed"] = True
            
            return migration_result
    
    def cleanup_backup(self) -> bool:
        """üßπ Nettoyage backup apr√®s migration r√©ussie"""
        try:
            if os.path.exists(self.backup_path):
                os.remove(self.backup_path)
                logger.info(f"üßπ Backup nettoy√©: {self.backup_path}")
                return True
            return False
        except Exception as e:
            logger.error(f"‚ùå Erreur nettoyage backup: {e}")
            return False

# === SCRIPT PRINCIPAL ===

def main():
    """üéØ Script principal migration V5"""
    print("="*60)
    print("üöÄ √âMERGENCE V5 - MIGRATION DATABASE")
    print("="*60)
    
    # Param√®tres
    database_path = "data/emergence_v4.db"
    
    print(f"üìÇ Database: {database_path}")
    print(f"üéØ Target: Tables sessions + m√©moire persistante")
    print()
    
    # Confirmation utilisateur
    confirm = input("üîß Continuer la migration ? (y/N): ").strip().lower()
    if confirm != 'y':
        print("‚ùå Migration annul√©e par l'utilisateur")
        return
    
    # Ex√©cution migration
    migrator = DatabaseMigrationV5(database_path)
    result = migrator.run_migration()
    
    # Affichage r√©sultats
    print("\n" + "="*60)
    print("üìä R√âSULTATS MIGRATION")
    print("="*60)
    
    print(f"‚úÖ Succ√®s: {'OUI' if result['success'] else 'NON'}")
    print(f"üíæ Backup cr√©√©: {'OUI' if result['backup_created'] else 'NON'}")
    print(f"üîÑ Rollback: {'OUI' if result['rollback_performed'] else 'NON'}")
    print(f"üìù √âtapes compl√©t√©es: {len(result['steps_completed'])}")
    
    if result["steps_completed"]:
        print(f"   ‚úÖ {', '.join(result['steps_completed'])}")
    
    if result["errors"]:
        print(f"‚ùå Erreurs: {len(result['errors'])}")
        for error in result["errors"]:
            print(f"   ‚ùå {error}")
    
    verification = result.get("verification", {})
    if verification:
        print(f"\nüîç V√âRIFICATION:")
        print(f"   Tables cr√©√©es: {len(verification.get('tables_created', []))}")
        print(f"   Index cr√©√©s: {len(verification.get('indexes_created', []))}")
        
        if verification.get("tables_created"):
            print(f"   ‚úÖ {', '.join(verification['tables_created'])}")
    
    # Nettoyage si succ√®s
    if result["success"] and result["backup_created"]:
        cleanup = input("\nüßπ Supprimer le backup ? (y/N): ").strip().lower()
        if cleanup == 'y':
            migrator.cleanup_backup()
    
    print(f"\n{'‚úÖ MIGRATION TERMIN√âE AVEC SUCC√àS' if result['success'] else '‚ùå MIGRATION √âCHOU√âE'}")
    print("="*60)

if __name__ == "__main__":
    main()